#!/usr/bin/env ruby

# This puppy is intended to be a standalone command line script written in ruby
# with useful features that are not out-of-the-box available for git -- Features like
# "add all files that haven't been added yet" or "add all files that have been modified"
# or "do an equivalent of svn-info."
#
# For example:
#   githelper show untracked 
#   githelper add untracked 
#   githelper show modified 
#   githelper add modified
#   githelper show both
#   githelper add both
#   githelper help
# 
#  Just for fun, the noun phrases and verbs and adjectives can appear in any order
#
#  The parser is way overkill
#
#  Wishlist: required verb modifiers.  trim the passthru tree.  utilize ruby 1.9 stuff
#

module Hipe
  
  # if this module proves useful it should be moved out of here! 
  module GorillaGrammar

    class UsageFailure < Exception; end  

    class ParseFailure < Exception; end  
    
    module RegexpTerminal
      # if a regexp looks like /^(alpha|beta|gamma)$/ then describe it as {alpha|beta|gamma}
      def describe
        s = to_s
        if (m = %r{\(\?-mix:\^\(([^\)]+)\)\$\)}.match(s))
          %<{#{m[1]}}>
        else
          s
        end
      end
      
      def matches token
        if (md = self.match(token))
          md.captures
        else
          nil
        end
      end
      
      attr_accessor :name
      def name
        @name.to_s
      end
      
    end
    
    module StringTerminal
      def describe
        self
      end
      def matches token
        self == token
      end
      def name
        self
      end
    end
    
    # can't define singleton / no virtual class for Symbol
    class SymbolTerminal
      def initialize(symbol)
        @internal = symbol
      end
      def describe
        @internal.inspect
      end
      def matches token
        token
      end
      def inspect
        @internal.inspect
      end
      def name
        @internal.to_s
      end
    end
    
    class NonTerminal
      def initialize data
        @phrase = data.delete(:phrase)
        @data = data
        (0..@phrase.size-1).each do |index|
          terminal = @phrase[index]
          case terminal
            when Regexp then terminal.extend RegexpTerminal; terminal.name = @data[:names][index]
            when String then terminal.extend StringTerminal
            when Symbol then @phrase[index] = SymbolTerminal.new(terminal)
            else raise UsageFailure.new("invalid type for terminal: "+terminal.class)
          end
        end
      end
      
      attr_accessor :phrase

      def self.clone nt
        # 2009-22-16 04:38 raggi: hipe: maybe you want to look at marshal_dump and marshal_load callbacks
        Marshal.load(Marshal.dump(nt))
      end
      
      def clean
        @data.delete(:grammar_index)
      end
      
      def [](i)
        @data[i]
      end
      
      def []=(i,x)
        @data[i] = x
      end
            
      def capture_names
        @phrase.map{|x| x.name.to_sym} 
      end
      
      def captures
        use_this = []
        capture_names.each_with_index { |name, index| use_this << name; use_this << @data[:matches][index] }
        Hash[*use_this]
      end
      
      def describe_accepting_state
        terminal = @phrase[@data[:grammar_index]]
        terminal.describe        
      end
      
      def matches(token)
        @phrase[@data[:grammar_index]].matches(token)
      end
    end # class NonTerminal
  
    class GorillaParse
      def initialize verb, modifiers
        @verb = verb
        @modifiers = modifiers
      end
      
      attr_reader :verb, :modifiers
            
      def as_key
        @verb.capture_names.map{|x|x.to_s}.join('_').to_sym
      end  
      
    end # class
    
    class Grammar
    
      def initialize grammar
        @grammar = grammar
        @on_ambiguity = :fail; # :get_longest, :return_all, :fail
        @debug_level = 100
      end # def initialize
    
      def parse input_list
        @on_ambiguity = :get_longest
        verb_non_terminal = _parse(@grammar[:verbs],input_list)
        modifier_nts = []
        if (verb_non_terminal[:modifiers])
          @on_ambiguity = :return_all
          # if we wanted to be really anal we would parse the first half and 
          # second half separately to avoid interference but it seems like overkill at this early point.
          # and almost never a big deal unless really ambiguous G's
          shrinkme = input_list.clone
          nillify shrinkme, verb_non_terminal[:i1]..verb_non_terminal[:i2]
          matches = _parse(verb_non_terminal[:modifiers],shrinkme)
          matches.each do |match|
            nillify shrinkme, match[:i1]..match[:i2]
            modifier_nts << match
          end
          if (0<shrinkme.compact!.size)
            raise ParseFailure.new(%{I can't make sense of "#{shrinkme.inspect}"})
          end
        end # end if modifiers existed
        GorillaParse.new(verb_non_terminal, modifier_nts)
      end
        
      def nillify from_array, range
        range.each { |x| from_array[x] = nil }
      end

      def debug(level,puts=false,&block)
        return if (@debug_level < level)
        if puts
          puts yield
        else 
          print yield
        end
      end
      
      def debugs(level,&block)
        return debug(level, true, &block)
      end
    
      def _parse(phrases_data_list,input_list)
        pz = [] # possibilities as NonTerminal objects
        phrases_data_list.each do |terminal_symbol_list,freeform_data|
          freeform_data = {} if (true==freeform_data || 1==freeform_data)
          freeform_data.merge!(:grammar_index=>0, :i1=>false, :phrase=>terminal_symbol_list)
          pz << NonTerminal.new(freeform_data)
        end
        begin
          prev_pz = pz
          pz = __parse(pz, input_list)
          if (pz.size == 0)
            raise ParseFailure.new("parse failure")
          elsif (pz.find_all{|nt| nt[:matched] }.size == pz.size)
            if (pz.size == 1 ) 
              match = pz[0]
              break;
            else
              case @on_ambiguity
                when :get_longest
                  p pz,1
                  
                  lengths = pz.map { |x| x[:phrase].length }
                  max = lengths.max
                  if (lengths.find_all{|x| x==max}.size > 1)
                    raise UsageFailure.new(
                      "Ambiguous grammar and can't find longest match! There is more than one with same length!"
                    )
                  else
                    index = lengths.find_index(max)
                    match = pz[index]
                    break
                  end
               when :return_all
                 match = pz # careful
                 break
               when :fail
                 raise UsageFailure.new("Ambiguous grammar!")
               else
                 raise UsageFailure.new(%{invalid "@on_ambiguity" value "#{@on_ambiguity.inspect}"})
              end
            end
          else # we have at least one ongoing possibility that isn't done
            #ppp :poss, pz
          end
        end while true
        if (:return_all==@on_ambiguity && !match.instance_of?(Array))  # ick
          [match]
        else 
          match
        end
      end # def parse

      def __parse(pz, input_list)
        result_pz = []      
        pz.each do |nt|
          if nt[:matched] then result_pz << NonTerminal.clone(nt); next; end
          debugs(1){ %{****checking possibility of this phrase: #{nt.phrase.inspect}} }
          input_list_indexes = nt[:i2] ? [nt[:i2]] : (0..input_list.size-1).to_a
          input_list_indexes.each do |input_index|
            token = input_list[input_index]
            debug(1){%{checking input word "#{token}" against terminal symbol "#{nt.describe_accepting_state}"}}
            if (!(match_data = nt.matches(token)))
              debug(1){" and not adding\n"}
            else
              debug(1){" and adding \n"}
              nt2 = NonTerminal.clone(nt)
              nt2[:matches] ||= []
              nt2[:matches] << match_data          
              nt2[:i1] = input_index if nt2[:i1] == false
              if nt2[:grammar_index] == (nt2.phrase.size-1)
                nt2[:matched] = true
                nt2[:i2] = nt2[:i1] unless nt2[:i2]
              else
                nt2[:i2] = (nt2[:i2]) ? (nt2[:i2]+1) : (nt2[:i1]+1)
              end
              nt2[:grammar_index] += 1
              result_pz << nt2
            end
          end
        end
        result_pz
      end # def __parse
    end # class Grammar
  end # module GorillaGrammar
end # module Hipe

###### start temporary echo debugging ######

require 'pp'

def p symbol, object=nil, die=nil
  unless (symbol.instance_of?(Symbol) || symbol.instance_of?(String))
    die = object
    object = symbol
    symbol = 'YOUR VALUE'
  end
  puts spp(symbol, object)
  if die
    exit
  end
end

# PrettyPrint.pp() that returns a string instead (like puts) of print to standard out, 
# like sprintf() is to printf().  prints info about where it was called from.
def spp label, object
  # go backwards up the call stack, skipping caller methods we don't care about (careful!)
  # this is intended to show us the last interesting place from which this was called.
  i = line = methname = nil
  caller.each_with_index do |line,index|
    matches = /`([^']+)'$/.match(line)
    break if (matches.nil?) # almost always the last line of the stack -- the calling file name
    matched = /(?:\b|_)(?:log|p|spp)(?:\b|_)/ =~ matches[1]
    break unless matched
  end
  m = /^(.+):(\d+)(?::in `(.+)')?$/.match line
  raise CliException.new(%{oops failed to make sense of "#{line}"}) unless m
  path,line,meth = m[1],m[2],m[3]
  file = File.basename(path)
  PP.pp object, obj_buff=''
  
  # location = "(at #{file}:#{meth}:#{line})"
  location ="(at #{file}:#{line})"        
  if (location == @last_location)
    location = nil
  else 
    @last_location = location
  end
  
  buff = '';
  buff << label.to_s + ': ' if label
  buff << location if location
  buff << "\n" if (/\n/ =~ obj_buff)
  buff << obj_buff
  buff
end

###### end temporary echo debugging ######

if File.basename($PROGRAM_NAME) == File.basename(__FILE__) && ARGV[0] != 'gorillatest'
  module Hipe
    class GitHelper
      def initialize
        @version = '0.0.1beta'
      end
      
      def run argv
        parser = GorillaGrammar::Grammar.new({
          :verbs => {
            #['show', /^(modified|untracked)$/] => {:passthru=>{:capture_names=>[:which]}}, #* fixme!!!
            #['add',  /^(both|modified|untracked)$/] => {:passthru=>{:capture_names=>[:which]}},
            ['tell', /^(.+)$/, :subject, 'said', :something] => {
              :names => {1=>:who},
              :modifiers => {['rather','loudly']=>1}
            }
           #['help'] => {},
           #['version'] => {}
          }
        })
        if (0==ARGV.size || ['--help','-h'].include?(ARGV[0]))        
          ARGV[0] = 'help'
        elsif (['-v','--version'].include?(ARGV[0]))
          ARGV[0] = 'version'
        end
        parse = parser.parse(ARGV) # throws
        send('execute_'+parse.as_key.to_s, parse)
      end # def run

      def program_name
        File.basename($PROGRAM_NAME)        
      end
      
      def execute_help args
        puts <<-END.gsub(/^ {8}/, '')
        Helpful little additions to git.
        Usage:
          #{program_name} info                              Ruby version of Duane Johnson's 
                                                      script that is similar to svn info
          #{program_name} add  {modified|untracked|both}    Adds all files of that kind
          #{program_name} show {modified|untracked}         Show a preview of what files would
                                                      be added
          #{program_name} help                              Shows this screen
          #{program_name} version                           Shows version number
        END
      end
      
      def execute_version args
        puts %{#{program_name} version #{@version}}
      end
      
      def execute_show_which(args)
        ppp :args, args, 1
      end
      
      def execute_tell_who_subject_said_something(tree)
        caps = tree.verb.captures
        tree.modifiers.each { |mod| caps.merge! mod.captures }
        puts %{hey #{caps[:who][0]}, #{caps[:subject]} said "#{caps[:something]}"}
      end
      
    end # class GitHelper
  end # module Hipe  
  Hipe::GitHelper::new.run(ARGV)
end # if running this file



# in lieu of proper tests -- this is for GorillaGrammar only
if File.basename($PROGRAM_NAME) == File.basename(__FILE__) && ARGV[0] == 'gorillatest'
  grammar = Hipe::GorillaGrammar::Grammar.new({
    :verbs => {
     ['make','this'] => {
       :modifiers => {
         ['with','that'] => true, 
         ['with','the', 'other'] => true
       } 
     },
     ['make','that'] => {
       :modifiers => {
         ['now'] => true
       }
     },
     ['say', 'this', 'word', :thiz] => {
       :modifiers => {
         ['to', :who] => true,
         ['really', 'loudly'] => true         
       }
     },
     ['say', 'something'] => {
       :modifiers => { 'xxxx'=>'blah' }
     },
     ['run'] => {
     
     }
   }
 });

  puts "\n\n\n\n"
  
  parse_tree = grammar.parse(['to','jim','say','this','word','englefish','really','loudly'])
  
  p :parse_tree, parse_tree 
  
end

# pz.to_enum.with_index.select{|e,i| e > 5 }.map{|e,i| i } from manveru sunday 18:08    
# we considered using Diff::LCS.LCS for this but -- we need contiguous matches